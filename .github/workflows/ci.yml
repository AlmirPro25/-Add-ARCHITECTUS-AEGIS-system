
name: TACTICAL CI PIPELINE

on:
  push:
    branches: [ "main", "develop" ]
  pull_request:
    branches: [ "main" ]

jobs:
  integrity-check:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
    - uses: actions/checkout@v3

    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        cache-dependency-path: '**/package-lock.json'

    # Setup Backend & Shared
    - name: Install Backend Deps
      run: |
        cd backend
        npm ci
        npx prisma generate
      env:
        DATABASE_URL: file:./test_db.sqlite # Use a temporary test database for CI

    # Setup Frontend
    - name: Install Frontend Deps
      run: |
        cd frontend
        npm ci

    # Code Quality (assuming lint scripts are defined in package.json)
    - name: Lint Analysis (Backend)
      run: cd backend && npm run lint --if-present
    
    - name: Lint Analysis (Frontend)
      run: cd frontend && npm run lint --if-present

    # Unit Tests (assuming test scripts are defined in package.json)
    - name: Execute Backend Unit Tests
      run: cd backend && npm test --if-present
      env:
        DATABASE_URL: file:./test_db.sqlite
        JWT_SECRET: ci_test_secret

    - name: Execute Frontend Unit Tests
      run: cd frontend && npm test --if-present # If frontend has unit tests

  build-validation:
    needs: integrity-check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Build Docker Backend (Production Stage)
        run: docker build -f docker/Dockerfile.backend -t tactical-backend:test . --target runner
        
      - name: Build Docker Frontend (Production Stage)
        run: docker build -f docker/Dockerfile.frontend -t tactical-frontend:test . --target nginx

  e2e-tests:
    needs: build-validation
    runs-on: ubuntu-latest
    services:
      backend:
        image: tactical-backend:test # Use the image built in previous step
        ports: ['3000:3000']
        env:
          JWT_SECRET: e2e_test_secret
          DATABASE_URL: file:/tmp/e2e_test_db.sqlite
          PORT: 3000
        healthcheck:
          test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3000/api/health || exit 1"]
          interval: 5s
          timeout: 2s
          retries: 5
      frontend:
        image: tactical-frontend:test # Use the image built in previous step
        ports: ['80:80']
        depends_on:
          backend:
            condition: service_healthy
        healthcheck:
          test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:80 || exit 1"]
          interval: 5s
          timeout: 2s
          retries: 5
    steps:
      - uses: actions/checkout@v3
      - name: Install Playwright dependencies
        run: npm install -g playwright && playwright install
      - name: Run E2E tests
        run: npx playwright test tests/e2e/tactical.spec.ts
        env:
          # Frontend is exposed on port 80 by Nginx in the frontend service
          FRONTEND_BASE_URL: http://localhost
```

<script type="text/plain" data-path=".github/workflows/deploy.yml">
name: DEPLOY TO COMMAND CENTER

on:
  push:
    tags:
      - 'v*' # Trigger on any tag starting with v (e.g., v1.0.0, v2.0.4)

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production # Use a GitHub environment for production deployments

    steps:
      - uses: actions/checkout@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract Docker image tag
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ secrets.DOCKERHUB_USERNAME }}/tactical-backend
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest,enable=${{ github.ref == format('refs/tags/{0}', steps.meta.outputs.version) }}

      - name: Build and Push Backend Image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/Dockerfile.backend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          target: runner # Build only the production runner image

      - name: Build and Push Frontend Image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/Dockerfile.frontend
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/tactical-frontend:${{ steps.meta.outputs.version }},${{ secrets.DOCKERHUB_USERNAME }}/tactical-frontend:latest
          target: nginx # Build only the Nginx production image

      - name: Deploy via SSH to Remote Host
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "Deployment started on remote host."
            # Ensure target directory exists and navigate into it
            mkdir -p /opt/tactical-surveillance
            cd /opt/tactical-surveillance

            # Create/Update .env file on remote server if not present or needs update
            # WARNING: This approach requires secrets to be passed.
            # A more secure approach might involve pulling from a private secrets manager.
            echo "JWT_SECRET=${{ secrets.JWT_SECRET }}" > .env
            echo "FRONTEND_URL=${{ secrets.FRONTEND_URL }}" >> .env
            echo "DATABASE_URL=file:/app/prisma/db/tactical_db.sqlite" >> .env # Default for prod docker-compose

            # Pull the latest images
            docker-compose -f docker-compose.prod.yml pull

            # Bring up services using the production compose file
            docker-compose -f docker-compose.prod.yml up -d --remove-orphans

            # Clean up old Docker images to save space
            docker image prune -f

            echo "Deployment completed successfully."
        env: # Pass environment variables needed for the remote script
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
```

<script type="text/plain" data-path="tests/e2e/tactical.spec.ts">
import { test, expect } from '@playwright/test';

// Define a base URL for the frontend, defaulting to local Vite dev server
const FRONTEND_BASE_URL = process.env.FRONTEND_BASE_URL || 'http://localhost:5173';

test.describe('TACTICAL MISSION CONTROL - E2E', () => {
  
  test('Should load Landing Page and navigate to Dashboard', async ({ page }) => {
    await page.goto(FRONTEND_BASE_URL);

    // 1. Verify Landing Page Title and Elements
    await expect(page).toHaveTitle(/Architectus Aegis/);
    await expect(page.getByRole('heading', { name: /ARCHITECTUS AEGIS/i })).toBeVisible();
    await expect(page.getByText(/SECURE SYSTEMS ACCESS POINT/i)).toBeVisible();

    // 2. Navigate to Mission Control Dashboard
    await page.getByRole('link', { name: /MISSION CONTROL/i }).click();
    await page.waitForURL('**/dashboard');
    await expect(page).toHaveTitle(/Architectus Aegis | Tactical Monitor/);

    // 3. Check for Critical UI Components on Dashboard
    await expect(page.getByRole('heading', { name: /ARCHITECTUSAEGIS/i })).toBeVisible();
    await expect(page.getByText(/Active Field Assets/i)).toBeVisible(); // Updated text
    // Assuming a div with ID tactical-map is the map container
    await expect(page.locator('#tactical-map')).toBeVisible(); 
    await expect(page.getByText(/Target Telemetry/i)).toBeVisible();
    // Initially Mission Logs is for selected device, OsintSearch is default
    await expect(page.getByRole('heading', { name: /OPEN SOURCE INTELLIGENCE/i })).toBeVisible();
  });

  test('Should simulate Agent connection and telemetry flow', async ({ page, context }) => {
    // Create a new page for the agent to simulate a separate device
    const agentPage = await context.newPage();
    await agentPage.goto(`${FRONTEND_BASE_URL}/agent`);

    // AGENT SIDE: Register device
    await expect(agentPage.getByText(/No existing agent identity found/i)).toBeVisible();
    await agentPage.getByRole('button', { name: /Establish Identity/i }).click();
    await expect(agentPage.getByText(/Identity Confirmed:/i)).toBeVisible();
    await expect(agentPage.getByText(/AUTHENTICATED/i)).toBeVisible();

    // AGENT SIDE: Activate Uplink
    await agentPage.getByRole('button', { name: /Activate Tracker/i }).click();
    await expect(agentPage.getByText(/Active Uplink Established/i)).toBeVisible();
    await expect(agentPage.getByText(/TRANSMITTING/i)).toBeVisible();
    
    // Grant geolocation permission if prompted
    await context.grantPermissions(['geolocation']);

    // DASHBOARD SIDE: Navigate to Dashboard
    await page.goto(`${FRONTEND_BASE_URL}/dashboard`);
    await expect(page).toHaveTitle(/Architectus Aegis | Tactical Monitor/);
    
    // Wait for the agent to appear in the device list
    await page.waitForSelector('.group:has-text("SIGNAL LOCK")', { timeout: 15000 });
    const agentDeviceEntry = page.locator('.group:has-text("SIGNAL LOCK")');
    await expect(agentDeviceEntry).toBeVisible();

    // Select the newly connected agent
    await agentDeviceEntry.click();
    await expect(page.getByText(/Target Telemetry:/i)).toContainText('AGENT-');

    // Verify telemetry updates (e.g., battery, GPS coordinates on map)
    await expect(page.locator('.leaflet-marker-icon')).toBeVisible({ timeout: 10000 });
    await expect(page.getByText(/Battery Level:/i)).toBeVisible(); // Will update dynamically
    
    // AGENT SIDE: Terminate Uplink
    await agentPage.getByRole('button', { name: /Terminate Uplink/i }).click();
    await expect(agentPage.getByText(/Uplink TERMINATED/i)).toBeVisible();
    await expect(agentPage.getByText(/IDLE/i)).toBeVisible();

    // DASHBOARD SIDE: Verify agent status change
    await page.waitForSelector('.group:has-text("LOST LINK")', { timeout: 10000 });
    await expect(agentDeviceEntry).toContainText('LOST LINK');

    await agentPage.close();
  });

  test('Should perform OSINT search and display results', async ({ page }) => {
    await page.goto(`${FRONTEND_BASE_URL}/dashboard`);
    await expect(page).toHaveTitle(/Architectus Aegis | Tactical Monitor/);

    // Ensure the OSINT panel is visible (initially no device selected)
    await expect(page.getByRole('heading', { name: /OPEN SOURCE INTELLIGENCE/i })).toBeVisible();
    
    // Perform a search
    const osintSearchInput = page.getByPlaceholder(/Search for target/i);
    await expect(osintSearchInput).toBeVisible();
    
    await osintSearchInput.fill('John Doe email');
    await page.getByRole('button', { name: /SEARCH/i }).click();

    await expect(page.getByText(/Executing deep scan... please standby/i)).toBeVisible({ timeout: 10000 });
    await expect(page.getByText(/Profile Match/i)).toBeVisible({ timeout: 10000 });
    await expect(page.getByText(/Email Exposure Report/i)).toBeVisible();
    await expect(page.getByText(/john.doe.email@example.com/i)).toBeVisible(); // More dynamic example match
  });

  test('Should handle WebRTC stream request from Dashboard to Agent', async ({ page, context }) => {
    // Create an agent page
    const agentPage = await context.newPage();
    await agentPage.goto(`${FRONTEND_BASE_URL}/agent`);
    await agentPage.getByRole('button', { name: /Establish Identity/i }).click();
    await agentPage.getByRole('button', { name: /Activate Tracker/i }).click();
    
    await expect(agentPage.getByText(/Active Uplink Established/i)).toBeVisible();
    const agentId = (await agentPage.evaluate(() => localStorage.getItem('device_id'))) as string;

    // DASHBOARD SIDE: Go to dashboard
    await page.goto(`${FRONTEND_BASE_URL}/dashboard`);
    await page.waitForSelector(`.group:has-text("${agentId.substring(0,4)}")`); // Wait for agent to appear
    
    // Select the agent and request stream
    await page.locator(`.group:has-text("${agentId.substring(0,4)}")`).click();
    await page.locator(`.group:has-text("${agentId.substring(0,4)}")`).getByRole('button', { name: /Request Live Stream/i }).click();

    // Grant camera/microphone permission on agent side if prompted
    await context.grantPermissions(['camera', 'microphone']);

    // AGENT SIDE: Verify stream activity
    await expect(agentPage.getByText(/LIVE FEED ACTIVE/i)).toBeVisible({ timeout: 15000 });
    await expect(agentPage.locator('video')).toBeVisible();

    // DASHBOARD SIDE: Verify remote video stream is active
    await expect(page.getByText(/LIVE STREAM: AGENT-/i)).toBeVisible({ timeout: 20000 });
    await expect(page.locator('video')).toBeVisible();

    // Stop stream from dashboard
    await page.getByRole('button', { name: /TERMINATE STREAM/i }).click();
    await expect(page.locator('video')).not.toBeVisible();
    await expect(agentPage.getByText(/LIVE FEED ACTIVE/i)).not.toBeVisible();

    await agentPage.close();
  });

  test('Should be responsive on mobile viewport', async ({ page }) => {
    // Simulate mobile device
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto(FRONTEND_BASE_URL);
    
    // Expect landing page links to adapt for mobile (stacked)
    const missionControlLink = page.getByRole('link', { name: /MISSION CONTROL/i });
    const fieldAgentLink = page.getByRole('link', { name: /FIELD AGENT/i });
    
    // Check if they are displayed as blocks (typical for mobile stacked)
    await expect(missionControlLink).toHaveCSS('display', 'block');
    await expect(fieldAgentLink).toHaveCSS('display', 'block');

    // Navigate to dashboard
    await missionControlLink.click();
    await page.waitForURL('**/dashboard');

    // On mobile, the layout should adapt. E.g., sidebars might be hidden or collapsible.
    // For this design, it's a grid, so it might just overflow or stack depending on CSS.
    // Let's check for the header and the main map being visible.
    await expect(page.getByRole('banner')).toBeVisible(); // Header
    await expect(page.locator('#tactical-map')).toBeVisible(); // Map
    // Sidebars might require scrolling or a toggle to view on small screens
    // No specific mobile-adaptive components like hamburger menu were implemented,
    // so this test verifies basic visibility of core elements.
  });
});
```

<script type="text/plain" data-path=".env.example">
# =====================================
# AEGIS SYSTEM CONFIGURATION
# =====================================

# Server Port (Backend API and WebSockets)
PORT=3000

# JWT Secret for authentication tokens. MUST BE A STRONG, RANDOM STRING IN PRODUCTION.
JWT_SECRET="YOUR_SUPER_SECRET_TACTICAL_KEY_CHANGEME_IMMEDIATELY"

# Frontend URL (used by CORS in backend, and by Nginx proxy in production)
# In development, Vite handles proxying so this might not be strictly needed by backend.
# In production, this should be the public URL of your frontend.
FRONTEND_URL=http://localhost:80
